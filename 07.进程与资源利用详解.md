# 进程与资源利用详解

-   [进程跟踪](#进程跟踪)
-   [使用lsof查看打开的文件](#使用lsof查看打开的文件)
-   [跟踪程序执行和系统调用](#跟踪程序执行和系统调用)
    -   [strace命令](#strace命令)
    -   [ltrace命令](#ltrace命令)
-   [线程](#线程)
    -   [单线程进程和多线程进程](#单线程进程和多线程进程)
    -   [查看线程](#查看线程)
-   [资源监控简介](#资源监控简介)
-   [测量CPU时间](#测量CPU时间)
-   [平均负载](#平均负载)
-   [参考](#参考)

------

## 进程跟踪

你可以通过键盘向top发送命令。下面是一些比较重要的键盘命令。

```
空格键 立即更新显示内容。
M 按照当前内存使用量排序。
T 按照CPU累计使用量排序。
P 按照当前CPU使用量(默认)排序。 u 仅显示某位用户的进程。
f 选择不同的统计信息来显示。
? 为所有top命令显示使用情况统计。
```

Linux中另外还有两个类似于top的工具，提供更详细的信息和更丰富的功能，它们是atop和 htop

## 使用lsof查看打开的文件

lsof命令列出打开的文件以及使用它们的进程。由于Unix系统大量使用文件，所以lsof在系 统排错方面是最有用的命令之一。但lsof不仅仅显示常规文件，还显示网络资源、动态库以及管 道等等。

lsof的输出结果通常信息量很大，如下面的例子中，你看到的只是其中一些片段。这一输出结果中包含init进程中打开的文件和运行中的vi进程

```
$ lsof
COMMAND PID USER FD TYPE DEVICE  SIZE NODE NAME
```

其中包含以下字段。

-   COMMAND:拥有文件描述符的的进程对应的命令名。
-   PIM:PID。
-   USER:运行进程的用户。
-   FD:该列包含两种元素。本例中FD列显示文件的作用。该列还能够显示打开文件的描述符。文件描述符是一个数字，进程通过它使用系统库和内核来进行文件标识和操作。

-   TYPE:文件类型(如常规文件、目录、套接字等)。
-   DEVICE:包含该文件的设备的主要代码和次要代码。
-   SIZE:文件大小。
-   NODE:文件的索引节点编号。
-   NAME:文件名。

运行lsof有以下两种基本方式。

-   输出完整的结果，然后将输出结果通过管道用命令less显示，然后在其中搜索你想要的内容。由于输出结果信息量很大，该方法可能会花点时间。
-   使用命令行选项来过滤lsof的输出结果。

你可以使用命令行选项提供一个文件名作为参数，然后使用lsof显示只和参数匹配的条目。 例如，下面的命令显示/usr目录中所有打开的文件:

```bash
$ lsof /usr
```

根据PID列出打开文件，使用以下命令:

```bash
$ lsof -p pid
```

>   lsof和内核信息密切相关。如果你升级内核时没有按常规升级系统的其他部分，你可能 需要升级lsof。如果你同时升级了内核和lsof，新的lsof可能需要你重新启动新内核以后 才能够正常工作。

## 跟踪程序执行和系统调用

到目前为止，我们介绍的工具都是针对运行中的进程。然而，有时候你的程序可能在系统启 动后马上就终止了，这时你可能会一头雾水，lsof命令也不管用了。实际上，使用lsof查看执行 失败的进程非常困难。

strace(系统调用跟踪)和ltrace(系统库跟踪)命令能够帮助你了解程序试图执行哪些操 作。它们的输出信息量都很大，不过一旦你确定了查找的范围，有很多工具可以帮助你定位需要 13 的信息。

### strace命令

之前介绍过，系统调用是用户空间请求内存执行的经过授权的操作，诸如打开文件、读取数据等等。strace能够显示进程涉及的所有系统调用。可以通过下面的命令查看:

```bash
$ strace cat /dev/null
```

### ltrace命令

ltrace命令跟踪对共享库的调用。它的输出结果和strace类似，所以我们在这里提一下。但 是它不跟踪内核级的内容。请记住，共享库调用比系统调用数量多得多。所以你有必要过滤ltrace 命令的输出结果。ltrace命令有很多选项可以帮到你。

## 线程

在Linux中，一些进程被细分为更小的部分，我们称为线程(thread)。线程和进程很类似， 它有一个标识符(即TID)。内核运行线程的方式和运行进程基本相同。但有一点不同，即进程之 间不共享内存和I/O这样的系统资源，而同一个进程中的所有线程则共享该进程占用的系统资源 和一些内存。

### 单线程进程和多线程进程

很多进程只有一个线程，叫单线程进程。有超过一个线程的叫多线程进程。所有进程最开始 都是单线程，起始线程通常称为主线程。主线程随后可能会启动新的线程，这样进程就变为多线 程。这个过程和进程使用fork()创建新进程类似。

多线程的主要优势在于，当进程要做的事情很多时，多个线程可以同时在多个处理器上运行， 这样可以加快进程的运行速度。虽然你也可以同时在多个处理器上运行多个进程，但线程相对进 程来说启动更快，并且线程间通过共享的进程内存来相互通信，比进程间通过网络和管道相互通信更加便捷高效。

一些应用程序使用线程来解决在管理多个I/O资源时遇到的问题。传统上来说，进程有时候 会使用fork()创建新的子进程来处理新的输入输出流。线程提供相似的机制，但却省去了启动新 进程的麻烦。

### 查看线程

默认情况下，ps和top命令只显示进程的信息。如果想查看线程的信息，可以添加一个m选项，

```bash
$ ps m
PID TTY           TIME CMD
598 ttys000    0:00.87 -zsh
```

## 资源监控简介

现在我们来介绍一下资源监控，包括CPU时间、内存和磁盘I/O。我们将从系统和进程两个 3 层面来了解。

很多人为了提高性能去深入了解Linux内核。然而，大部分Linux系统在默认配置下性能都不 错，很有可能你花了很多时间来优化系统，但实际效果甚微。特别是在你对系统没有足够了解的 时候更是如此。所以，与其使用各种工具来尝试性能优化，不如来看看内核如何在进程之间分配资源。

## 测量CPU时间

如果要监控进程，可以使用top命令加-p选项，如下所示:

```bash
$ top -p pid1 [-p pid2 ...]
```

使用time命令可以查看命令整个执行过程中占用的CPU时间。大部分shell提供的time命令只 显示一些基本信息，所以你可能需要运行/usr/bin/time。例如，如果要查看ls命令占用的CPU时间，可以运行以下命令:

```bash
$ /usr/bin/time ls

LICENSE    README.md  git_note   linux_note mac_note   shell_note vim_note
ls -G  0.00s user 0.00s system 52% cpu 0.009 total
```

其中三个关键字段分别代表以下含义。

-   user:用户时间，指CPU用来运行程序代码的时间，以秒为单位。在现在的处理器中，命令的运行速度很快，有些不超过一秒，time命令会将它们四舍五入为0。
-   system:系统时间，指内核用来执行进程任务的时间(例如读取文件和目录)。
-   elapsed:消耗时间，指进程从开始到结束所用的全部时间，包括CPU执行其他任务的时

## 平均负载

CPU的性能比较容易来衡量。平均负载(load average)是准备就绪待执行的进程的平均数。 也就是某一时刻可以使用CPU的进程数的一个估计值。系统中大多数进程通常把时间花在等待输 入上(如从键盘、鼠标、网络等)，这意味着这些进程没有准备就绪可执行，所以并不计入平均 负载。只有那些真正在运行的进程才计入平均负载。

uptime命令显示三个平均负载值和内核已经运行的时长

```bash
$ uptime

19:22  up  3:27, 2 users, load averages: 3.32 2.46 2.34
```

## 参考

[精通linux(第二版)](https://www.ituring.com.cn/book/1548)